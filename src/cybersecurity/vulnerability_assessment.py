"""
Cybersecurity Vulnerability Assessment Module

Implements secure CVE database integration with rate limiting, input validation,
and comprehensive security controls for vulnerability research.
"""

import requests
import logging
import re
import time
from urllib.parse import quote
from typing import Dict, List, Optional
from bs4 import BeautifulSoup

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

class VulnerabilityAssessor:
    """Secure vulnerability assessment with rate limiting and input validation."""
    
    def __init__(self, base_url: str = "https://cve.mitre.org/cgi-bin/cvekey.cgi", 
                 rate_limit: float = 1.0, timeout: int = 10):
        self.base_url = base_url
        self.rate_limit = rate_limit  # Seconds between requests
        self.timeout = timeout
        self.last_request_time = 0.0
        self.session = requests.Session()
        self.session.headers.update({
            'User-Agent': 'VulnerabilityAssessor/1.0 (Security Research)'
        })

    def validate_search_term(self, term: str) -> bool:
        """Validate search term to prevent injection attacks."""
        if not isinstance(term, str) or len(term) > 100:
            return False
        
        # Allow alphanumeric, dots, hyphens, and underscores only
        pattern = re.compile(r'^[a-zA-Z0-9\.\-_]+$')
        return bool(pattern.match(term))

    def _rate_limit_wait(self) -> None:
        """Implement rate limiting between requests."""
        current_time = time.time()
        elapsed = current_time - self.last_request_time
        if elapsed < self.rate_limit:
            time.sleep(self.rate_limit - elapsed)
        self.last_request_time = time.time()

    def fetch_vulnerabilities(self, search_term: str) -> List[str]:
        """Fetch known vulnerabilities for a given search term from public databases."""
        if not self.validate_search_term(search_term):
            logger.warning(f"Invalid search term: {search_term}")
            return []

        self._rate_limit_wait()
        
        try:
            # URL encode the search term to prevent injection
            encoded_term = quote(search_term, safe='')
            url = f"{self.base_url}?keyword={encoded_term}"
            
            logger.info(f"Fetching vulnerabilities for: {search_term}")
            response = self.session.get(url, timeout=self.timeout)
            response.raise_for_status()
            
            soup = BeautifulSoup(response.text, 'html.parser')
            vulnerabilities = []
            
            # Extract CVE identifiers with validation
            for item in soup.find_all('a', href=True):
                text = item.get_text(strip=True)
                # Validate CVE format: CVE-YYYY-NNNN
                if re.match(r'^CVE-\d{4}-\d{4,}$', text):
                    vulnerabilities.append(text)
            
            logger.info(f"Found {len(vulnerabilities)} vulnerabilities for {search_term}")
            return vulnerabilities
            
        except requests.exceptions.RequestException as e:
            logger.error(f"Request failed for {search_term}: {e}")
            return []
        except Exception as e:
            logger.error(f"Unexpected error for {search_term}: {e}")
            return []

    def assess_vulnerabilities(self, search_terms: List[str], max_terms: int = 5) -> Dict[str, List[str]]:
        """Assess vulnerabilities for multiple search terms with rate limiting."""
        if not isinstance(search_terms, list) or len(search_terms) > max_terms:
            raise ValueError(f"Invalid search terms list or too many terms (max: {max_terms})")
        
        vul_data = {}
        valid_terms = [term for term in search_terms if self.validate_search_term(term)]
        
        if len(valid_terms) != len(search_terms):
            logger.warning(f"Filtered {len(search_terms) - len(valid_terms)} invalid search terms")
        
        for term in valid_terms:
            vul_data[term] = self.fetch_vulnerabilities(term)
        
        return vul_data

# Backward compatibility functions
def fetch_vulnerabilities(host: str) -> List[str]:
    """Legacy function for backward compatibility."""
    assessor = VulnerabilityAssessor()
    return assessor.fetch_vulnerabilities(host)

def assess_vulnerabilities(hosts: List[str]) -> Dict[str, List[str]]:
    """Legacy function for backward compatibility."""
    assessor = VulnerabilityAssessor()
    return assessor.assess_vulnerabilities(hosts)